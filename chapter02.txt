第2章  链表问题
1.打印两个有序链表的公共部分（士 ★☆☆☆）
2.在单链表和双链表中删除倒数第K个节点（士 ★☆☆☆）
3.删除链表的中间节点和a/b处的节点（士 ★☆☆☆）
4.反转单向和双向链表（士 ★☆☆☆）
5.反转部分单向链表（士 ★☆☆☆）
6.环形单链表的约瑟夫问题（原问题：士 ★☆☆☆  进阶：校 ★★★★☆）
7.判断一个链表是否为回文结构（普通解法士 ★☆☆☆ 进阶解法尉 ★★☆☆）
8.将单向链表按某值划分成左边小、中间相等、右边大的形式（尉 ★★☆☆）
9.复制含有随机指针节点的链表（尉 ★★☆☆）
10.两个单链表生成相加链表（士 ★☆☆☆）
11.两个单链表相交的一系列问题（将 ★★★★）
12.将单链表的每K个节点之间逆序（尉 ★★☆☆）
13.删除无序单链表中值重复出现的节点（士 ★☆☆☆）
14.在单链表中删除指定值的节点（士 ★☆☆☆）
15.将搜索二叉树转换成双向链表（尉 ★★☆☆）
16.单链表的选择排序（士 ★☆☆☆）
17.一种怪异的节点删除方式（士 ★☆☆☆）
18.向有序的环形单链表中插入新节点（士 ★☆☆☆）
19.合并两个有序的单链表（士 ★☆☆☆）
20.按照左右半区的方式重新组合单链表（士 ★☆☆☆）

1.==========================================
打印两个有序链表的公共部分
【题目】 
给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。
==========================================

2.==========================================
在单链表和双链表中删除倒数第K个节点
【题目】
在单链表和双链表中删除倒数第K个节点。 
要求时间复杂度O(N)，空间复杂度O(1)。

【基本思路】

方法一。 
从链表头开始走到尾，每移动一步，k减1。移动完之后，如果k > 0，说明链表长度不够k，
根本就没有倒数第k个值，返回头节点 head；
如果k = 0，说明链表的长度等于k，头节点就是倒数第k个节点，返回 head.next；
如果 k < 0，说明链表的长度大于k，再次从头遍历链表，这时，每遍历一步就让k加1，
当 k = 0时，遍历到的节点就是倒数第k个节点的前一个节点，之后删除倒数第k个节点就很容易了。　
　 
为什么这么做是可行的？因为如果链表长度是N，要删除倒数第k个节点，显而易见，
第N - k个节点就是倒数第k个节点的前一个节点。第一次遍历的完后，k的值变为k - N，
第二次遍历的终止条件是k = 0，显然，k - N 加上 N - k 等于0，也就是说，
k = 0的时候，实际上就是遍历了N - k个节点。
所以当 k = 0时，遍历到的节点就是倒数第k个节点的前一个节点。

方法二。 
设置两个指针 fast 、slow，fast先走k步，如果走不到第k步
（None节点是可以走到的，但是None节点没有next，所以只能走到None），
说明链表长度不够k，直接返回head；如果走到第k步，发现该节点是None节点，
说明链表的长度等于k，头节点就是倒数第k个节点，返回 head.next；
否则，令 fast 和 slow 开始同步往下移动，直到 fast 移动到最后一个节点（不包含None），
此时slow就是倒数第 k 个节点的前一个节点，之后删除倒数第k个节点就很容易了。

单链表和双链表删除倒数第ｋ个节点的原理是一样的，只不过是双链表删除节点的时候稍微复杂一点。
==========================================

3.==========================================
删除链表的中间节点和a/b处的节点
【题目】
给定链表的头节点head，实现删除链表的中间节点的函数。 
例如： 
1，不删除任何节点 
1 -> 2，删除节点1 
1 -> 2 -> 3，删除节点2 
1 -> 2 -> 3 -> 4，删除节点2 
1 -> 2 -> 3 -> 4 -> 5，删除节点3

进阶问题： 
给定链表的头节点head，整数a和整数b，实现删除位于a/b处节点的函数。 
例如： 
链表：1 -> 2 -> 3 -> 4 -> 5k，假设a/b的值为r。 
如果r等于0，不删除任何节点 
如果r在区间(0, 1/5]上，删除节点1 
如果r在区间(1/5, 2/5]上，删除节点2 
如果r在区间(2/5, 3/5]上，删除节点3 
如果r在区间(3/5, 4/5]上，删除节点4 
如果r在区间(4/5, 1]上，删除节点5 
如果r大于1，不删除任何节点

【基本思路】

原问题。 
观察题目，我们可以发现，链表长度每增加2，要删除的节点就往后移动一位。我们只要利用这个规律找到要删除节点的前一个节点，问题就解决了。

进阶问题。 
首先，根据链表的长度n，以及a与b的值确定要删除的节点是哪一个节点。计算方法如下： 
r = math.ceil(a / b * n)，其中ceil函数是向上取整，a / b的值是浮点型。 
知道要删除哪一个节点后，只需要找到该节点的前一个节点即可。
==========================================

4.==========================================
反转单向和双向链表
【题目】
分别实现反转单向链表和反转双向链表的函数。 
要求，时间复杂度O(N)，空间复杂度O(1)。
==========================================

5.==========================================
反转部分单向链表
【题目】

给定一个单向链表的头节点head，以及两个整数start和end，在单向链表上把第start个节点到第end个节点这一部分进行反转。 
例如： 
1 -> 2 -> 3 -> 4 -> 5 -> null，start = 2，end = 4 
调整结果为：1 -> 4 -> 3 -> 2 -> 5 -> null 
再如： 
1 -> 2 -> 3 -> null，start = 1，end = 3 
调整结果为：3 -> 2 -> 1 -> null

【要求】

时间复杂度O(N)，空间复杂度O(1) 
如果不满足1 <= start <= end <= N，则不需要调整

【基本思路】

首先找到start的上一个节点，记为pre，end的下一个节点，记为pos。将start～end的节点反转，然后正确连接pre和pos即可。 

需要注意的是，如果pre不存在，说明头节点也在反转的部分，此时返回新的头节点，也就是反转部分的最后一个节点；
如果pre存在，说明头节点不在反转的部分，返回head即可。
==========================================

6.==========================================
环形单链表的约瑟夫问题
【题目】

据说著名犹太历史学家Josephus有过如下故事：在罗马人占领乔塔帕特后，
39个犹太人和Josephus及他的朋友躲进一个洞里，39个犹太人决定宁愿死也不要被敌人抓到，
于是决定了一个自杀方式，41个人排成一个圆圈，由第一个人开始报数，报数到3的人就自杀，
再由下一个人重新报1，报数到3的人就自杀，这样依次下去，知道剩下最后一个人时，
那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向链表描述该结构并呈现整个自杀过程。 
　　 
输入：一个环形单向链表的头节点head和报数的值m 
返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。

进阶：如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎么实现？

【基本思路】

普通解法。 
1、在环形链表中遍历每个节点，不断转圈，不断让每个节点报数。 
2、当报数为m时，就删除当前报数的节点。 
3、删除节点后把剩下的节点继续连成一个环，继续转圈报数，继续删除。 
4、不断的删除，直到只留下一个节点，过程结束。 
普通解法删除一个节点需要遍历m次，一共要删除n-1个节点，所以总的时间复杂度为O(n*m)。

进阶解法。 
普通解法之所以复杂度高，是因为我们不知道到底哪个节点会留下来。
所以依靠不断的遍历删除，直到只留下一个节点。如果我们能不通过遍历，
而是直接算出最后活下来的节点是哪个，就可以降低时间复杂度。

如何计算呢？首先如果环形链表的节点数为n，那么从头节点开始编号，头节点编号为1，下一个编号为2……最后一个节点编号为n。

定义Live(int n)函数，表示如果有n个节点，则返回最后幸存节点的编号，然后考虑如下： 
　　 
如果只剩下一个节点，那么幸存的节点就是该节点，编号为1，即Live(1) = 1 
如果剩下两个节点，幸存的节点为Live(2) 
如果剩下三个节点，幸存的节点为Live(3) 
如果剩下i-1个节点，幸存的节点为Live(i-1) 
如果剩下i个节点，幸存的节点为Live(i) 
如果剩下n个节点，幸存的节点为Live(n) 
　　 
已经知道live(1) = 1，如果再确定Live(i-1)和Live(i)到底是什么关系，我们就可以通过递归过程求出Live(n)。

首先我们分析如下问题：如果一个节点数为n的链表，编号从头节点到末尾为1～n，如果删除编号为s的一个节点，那么剩下的节点的编号将会如何变化，如图所示。 

设原链表中节点的编号为 old，删除一个节点后的编号为 new，删除的节点的编号记为 s，
我们可以得到如下的公式 old = (new + s - 1) % n + 1。
因此，我们可以根据Live(i-1)以及被删除的节点编号求得Live(i)的值。
那么现在的问题就变成了如何求被删除节点的编号。 

如图所示。对于每一个节点，如果报数值还不到m，就会一直报数下去，
1～n～2n……由图我们可以得到一个报数值A与编号B的关系，
即B = (A-1) % n + 1。如果报数报到m，删除该节点，
且该节点的编号根据公式可以得出 s = (m-1) % n + 1。

得到被删除节点的编号s，我们就可以得到Live(i-1)与Live(i)之间的关系：
Live(i) = (Live(i-1) + s - 1) % i + 1。其中Live(i-1)可以通过向上递归得到，
s = (m-1) % i + 1。两式合并后，结果为 Live(i) = (Live(i-1) + m - 1) % i + 1。

整个过程总结如下： 
1、遍历链表，得到链表的节点数n，O(n) 
2、根据n和m的值，以及上文推导的Live(i)与Live(i-1)的关系，递归求得幸存节点的编号。该递归是单决策递归且递归为n层，所以时间复杂度为O(n) 
3、根据得到的幸存节点的编号，遍历链表找到该节点，O(n) 
所以总体时间复杂度为O(n)。
==========================================